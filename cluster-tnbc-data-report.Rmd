---
title: "Cluster TNBC Data"
params:
  geo.dataset: GSE76250
output:
  html_document: default
---

The purpose of this RMarkdown document is to create Query Gene Signatures that represent the diseased
state of Triple-Negative Breast Cancer.


# Downloading the data
We're going to use a dataset of TNBC data from another article that was clustering TNBC data from The GEO dataset `r params$geo.dataset`.

For this we require Bioconductor's `GEOquery` to download the files:

```{r}
library('GEOquery')
dir.create('geodata')
tnbc.gene.set <- getGEO(params$geo.dataset, destdir="geodata")[[1]]
```

```{r}
case.row.nums <- which(pData(tnbc.gene.set)$source_name_ch1 == 'breast_TNBC')
case.ids <- pData(tnbc.gene.set)$geo_accession[case.row.nums]
control.row.nums <- which(pData(tnbc.gene.set)$source_name_ch1 == 'breast_normal tissue')
control.ids <- pData(tnbc.gene.set)$geo_accession[control.row.nums]
```

The resulting ExpressionSet contains `r ncol(tnbc.gene.set@assayData$exprs)` samples, of which there are 
`r length(case.ids)` TNBC expression profiles along with `r length(control.ids)` expression profiles for non-cancerous
adjacent tissue. The case and control samples are needed for performing our differential expression analysis to deduce
which genes we should use to perform the clustering. When performing the clustering, all control samples will be 
removed.

Before we perform the analysis, there are a number of steps required to prepare the data.

Most significantly, as this is a GEO GSE as opposed to a GDS, the microarray data has not already been normalized.
For this we can apply quantile normalization using the `limma` package:

```{r}
require('limma')

exprs(tnbc.gene.set) <- normalizeBetweenArrays(exprs(tnbc.gene.set))
```

Furthermore, as these microarray data were measured using the Affymetrix GeneChip&reg; Human Transcriptome Array 2.0,
there are duplicate probe IDs on the microarray which map to the same genes.

In accordance with the original Liu et al paper <!-- add reference here -->, we will remove genes with what is deemed a nominal small standard deviation, namely $\sigma \leq .65$ or $\sigma^2 \leq .65$

```{r}
require('genefilter')
# also download the annotation package for this microarray platform
require('hta20transcriptcluster.db')

# assign correct annotation package name to this GSE
annotation(tnbc.gene.set) <- 'hta20transcriptcluster.db'

min.variance <- .65 ^ 2

#perform filtering to retain probes with highest IQR
tnbc.gene.set <- genefilter::nsFilter(tnbc.gene.set, remove.dupEntrez =T,
                                           var.filter=T, var.cutoff=min.variance,
                                          filterByQuantile=F)

removed.element.details <- tnbc.gene.set[[2]]

tnbc.gene.set <- tnbc.gene.set[[1]]
```

Following the filtering, `r removed.element.details$numDupsRemoved` duplicate genes were removed,
`r removed.element.details$numLowVar` genes were removed due to low variance and `r removed.element.details$numRemoved.ENTREZID` were removed for having no entrez id <!-- perhaps stop this happening by 
setting require.entrez=F!!!!`-->.

# Differential Expression Analysis

We will use limma to perform differential expression analysis between the TNBC expression profiles and the 
adjacent tissue expression profiles. Firstly, let's calculate the vector of `outcome measurements` for each sample 
required by limma:

```{r}
col.names <- colnames(exprs(tnbc.gene.set))
label.fn <- function(sample.name) {
  if (sample.name %in% case.ids) {
    return(1)
  } else {
    return(2)
  }
}
outcome <- sapply(col.names, FUN=label.fn)
```

With these data we can perform the differential expression analysis. We will perform the differential expression analysis using the limma R package:

```{r}
design <- model.matrix(~ 0+factor(outcome))
colnames(design) <- c('case', 'control')
fit <- lmFit(tnbc.gene.set, design)
fit <- eBayes(fit)
top.genes <- topTable(fit, coef=2, number=50, adjust.method="fdr", p.value=0.05,lfc=0)
```

# Creating a global TNBC Query Gene Signature

In order for us to create a Query Gene Signature that's compatible with the the reference profiles, we need 
to convert the Affymetrix GeneChip&reg; Human Transcriptome Array 2.0 probe IDs into the equivalent probe IDs
from the Affymetrix HG-U133A microarray platform. This is a necessary step as the referenece profiles describing 
drug action used the latter platform.

To do this, we use the `biomaRt` package:

```{r biomaRt map ids}
library('biomaRt')

hta.ids <- as.character(top.genes$probeset_id)
mart <- useDataset('hsapiens_gene_ensembl', useMart('ensembl'))
summary <- getBM(filters='affy_hta_2_0', attributes= 
                   c("ensembl_gene_id", 'affy_hg_u133_plus_2', 'affy_hta_2_0', 'description'),
                 values=hta.ids,mart= mart)
```

We can see that there are `r nrow(summary)` rows that map between the two platforms in our top significantly 
differentiated genes. As such, it isn't possible for us to create a Query Gene Signature.

<!-- look at top diff expressed probes and see if they are coding/non-coding -->
We were unable to synthesise a query gene signature from the top differentially expressed probe ids over all 
TNBC samples. This may be due to the fact that all differentially expressed probe IDs mapped to probes for non-coding 
regions of the genome which is an attribute that differentiates the Human Tissue Array from the Human Genome U133 
Plus 2 platform.

# K-means Clustering by significantly differentially expressed genes

As we were unable to synthesise a global query gene signature that identified genes that mapped to probe ids on the 
target Affymetrix microarray platform, it might be that we get better results by identifying subtypes of TNBC by 
using clustering algorithms.

While the significantly differentially expressed probes were unable to be used to synthesise a query gene signature for TNBC, we can use these same probe IDs as the basis for clustering our data. K-means clustering will be performed
to find subtypes of triple-negative breast cancer.

Firstly, let's take the names of the significantly differentially expressed probe ids create an expression matrix 
with only these probe IDs. This will serve as input to our clustering algorithm.

```{r create subset expression matrix}
# limma version
diff.expressed.probe.ids <- as.character(top.genes$probeset_id)

rows <- which(row.names(exprs(tnbc.gene.set)) %in% diff.expressed.probe.ids)

# we only want non control id expression values
case.ids <- as.character(case.ids)
diff.expressed.expr.set <- exprs(tnbc.gene.set)[rows,case.ids]

# need to transpose for kmeans - rows = datapoints
diff.expr.transposed <- t(diff.expressed.expr.set)
```

Now we have the expression matrix for all samples that are differentially expressed we can go about clustering. But 
first we need to find the ideal number of clusters, `K*`. This can be approximated by using Rob Tibshirani's *gap statistic*:

<!-- TODO: try using kmeansW from https://cran.r-project.org/web/packages/FactoClass/FactoClass.pdf allows weighting of differential variables -->

```{r}
gap.statistic <- cluster::clusGap(diff.expr.transposed, cluster::pam,K.max=10, B=500)
plot(gap.statistic)
print(gap.statistic, method='Tibs2001SEmax')
```

We can see, according to the Tibshirani method, the optimal number of clusters (and therefore the ideal number of 
Triple-Negative Breast Cancer subtypes) from this sample of data is 4. This reflects the results found by Liu et al in their 
paper using the same datapoints albeit they performed a different clustering method called Consensus Clustering.

```{r perform-clustering}
clusters <- cluster::pam(diff.expr.transposed, k=4)
```

The data segregate into four clusters with the following distribution:

```{r distribution-of-clusters}
table(clusters$clustering)
```

Now that the expression values have been clustered into the optimal number of clusters, $K*$, we can now create query gene 
signatures for each subtype identified which will later be used to perform Gene Expression Connectivity Map such that we mightf find candidate therapies for each breast cancer subtype.

<!-- # Consensus Clustering
 
TODO use R package ConsensusClustPlus to find optimal numeber of clusters - method similar to original paper 
(Liu et al, 2016)

https://www.ncbi.nlm.nih.gov/pubmed/20427518
As no clusters were identified using a k-means clustering approach with Tibshirani's gap statistic, another approach is to 
use a consensus clustering approach implemented by the Bioconductor package ConsensusClusterPlus.

Consensus works by creating random subsamples of the original dataset and to perform a particular clustering algorithm (e.g. PAM or K-means) over multiple values for K. A consensus value is calculated for each value of K which indicates how cleanly
all of the clusters and the optimal K is evaluated by plotting an empirical cumulative distribution function.

## Perform Consensus Clustering with ConsensusClusterPlus
```{r}
!dir.exists('consensus_clust') &&  dir.create('consensus_clust')
library(ConsensusClusterPlus)
results = ConsensusClusterPlus(diff.expr.transposed,maxK=6,reps=50,pItem=0.8,pFeature=1,
title='consensus_clust',clusterAlg="hc",distance="pearson",seed=1262118388.71279,plot="png")
```
-->

<!-- TOOD add section discussing pathways involved in these subtypes -->
# Create QGSs for Subtypes

Now we have identifed these subtypes, we can partition our data according to the subtypes the samples segregate into.
From this we can create individual Query Gene Signatures for each subtype. Such that we can perform differential 
expression analysis on each of these subsets, it befits us to reintroduce the non TNBC samples to each of these 
expression matrices.

```{r partition data for subtypes}
tnbc.expr.data <- exprs(tnbc.gene.set)

create.clust.subset <- function(clust.num) {
  clust.sample.ids <- names(which(clusters$clustering == clust.num))
  
  sample.indices <- which(colnames(tnbc.expr.data) %in% clust.sample.ids)
  control.indices <- which(design[,2] == 1)
  # put the controls at the end
  return(tnbc.expr.data[,c(sample.indices, control.indices)])
}

clust.subsets <- lapply(X = list(clust1=1,clust2=2,clust3=3,clust4=4), FUN = create.clust.subset)
```

Now that we have created expression matrices for each of the four subsets we can now perform differential expression 
analysis on each as we did before globally. We will reuse the design matrix as bef

```{r subtype differential expression analysis}
find.top.genes <- function(expr.mat) {
  num.control <- length(which(design[,2] == 1))
  num.case <- ncol(expr.mat) - num.control
  
  control.flags <- c(rep(0, num.case), rep(1, num.control))
  case.flags <- c(rep(1, num.case), rep(0, num.control))

  clust.design.mat <- cbind(case.flags, control.flags)
  names(clust.design.mat) <- c('case', 'control')
  fit <- lmFit(expr.mat, clust.design.mat)
  fit <- eBayes(fit)
  return(topTable(fit, coef=2, number=50, adjust.method="fdr", p.value=0.05,lfc=0))
}

clust.top.genes <- lapply(X=clust.subsets, FUN = find.top.genes)
```

We can observe the overlap of the top 50 differentially expressed genes among the different clusters to see how 
similar or dissimilar the clusters are.

```{r subtype venn diagram sd genes}
library(VennDiagram)
clust.sd.genes <- lapply(X = clust.top.genes, FUN = function(exp.mat) rownames(exp.mat))
venn.diagram(clust.sd.genes, "ClusterSDGeneVennDiagram.tiff")
```

![Venn Diagram](./ClusterSDGeneVennDiagram.tiff)

